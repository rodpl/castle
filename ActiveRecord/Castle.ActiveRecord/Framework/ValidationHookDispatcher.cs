// Copyright 2004-2007 Castle Project - http://www.castleproject.org/
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

namespace Castle.ActiveRecord.Framework
{
	using System.Collections.Generic;

	using NHibernate;
	using NHibernate.Type;
	using Castle.ActiveRecord.Framework.Internal;
	using Castle.Components.Validator;

	/// <summary>
	/// This class processes the events generated by NHibernate and validates objects
	/// where the object is not derived from ActiveRecordBase. If you want to use it
	/// you could create a facility that replaces the default HookDispatcher along
	/// the lines of the following:
	/// <code>
	/// public class ValidateFacility : IFacility
	/// {
	///     public void Init(IKernel kernel, Castle.Core.Configuration.IConfiguration facilityConfig)
	///     {
	///         InterceptorFactory.Create = new InterceptorFactory.CreateInterceptor(CreateValidationInterceptor);
	///     }
	/// 
	///     private IInterceptor CreateValidationInterceptor()
	///     {
	///         return ValidationHookDispatcher.Instance;
	///     }
	/// }
	/// </code>
	/// </summary>
	public class ValidationHookDispatcher : EmptyInterceptor
	{
		private static readonly ValidationHookDispatcher instance = new ValidationHookDispatcher();

		/// <summary>
		/// Initializes a new instance of the ValidationHookDispatcher class.
		/// </summary>
		protected ValidationHookDispatcher()
		{
		}

		/// <summary>
		/// Gets the sole instance.
		/// </summary>
		/// <value>The instance.</value>
		public static ValidationHookDispatcher Instance
		{
			get { return instance; }
		}

		/// <summary>
		/// Called when an object is detected to be dirty, during a flush.
		/// </summary>
		/// <param name="currentState"></param>
		/// <param name="entity"></param>
		/// <param name="id"></param>
		/// <param name="previousState"></param>
		/// <param name="propertyNames"></param>
		/// <param name="types"></param>
		/// <remarks>
		/// The interceptor may modify the detected <c>currentState</c>, which will be propagated to
		/// both the database and the persistent object. Note that all flushes end in an actual
		/// synchronization with the database, in which as the new <c>currentState</c> will be propagated
		/// to the object, but not necessarily (immediately) to the database. It is strongly recommended
		/// that the interceptor <b>not</b> modify the <c>previousState</c>.
		/// </remarks>
		/// <returns><c>true</c> if the user modified the <c>currentState</c> in any way</returns>
		public override bool OnFlushDirty(object entity, object id, object[] currentState, object[] previousState, string[] propertyNames, IType[] types)
		{
			IsValid(entity, RunWhen.Update);

			return false;
		}

		/// <summary>
		/// Called before an object is saved
		/// </summary>
		/// <param name="entity"></param>
		/// <param name="id"></param>
		/// <param name="propertyNames"></param>
		/// <param name="state"></param>
		/// <param name="types"></param>
		/// <remarks>
		/// The interceptor may modify the <c>state</c>, which will be used for the SQL <c>INSERT</c>
		/// and propagated to the persistent object
		/// </remarks>
		/// <returns><c>true</c> if the user modified the <c>state</c> in any way</returns>
		public override bool OnSave(object entity, object id, object[] state, string[] propertyNames, IType[] types)
		{
			IsValid(entity, RunWhen.Insert);

			return false;
		}

		private void IsValid(object entity)
		{
			IsValid(entity, RunWhen.Everytime);
		}

		private void IsValid(object entity, RunWhen runWhen)
		{
			ValidatorRunner runner = new ValidatorRunner(ActiveRecordModelBuilder.ValidatorRegistry);

			if (!runner.IsValid(entity, runWhen))
			{
				List<string> errorList = new List<string>();

				ErrorSummary summary = runner.GetErrorSummary(entity);

				foreach (string invalidProperty in summary.InvalidProperties)
				{
					foreach (string errorMessage in summary.GetErrorsForProperty(invalidProperty))
					{
						errorList.Add(string.Format("{0} - {1}", invalidProperty, errorMessage));
					}
				}

				string[] errorMessages = errorList.ToArray();
				throw new ValidationException("Can't save or update as there is one (or more) field that has not passed the validation test", errorMessages);
			}
		}
	}
}
