<% @page_title = "Extending the MicroKernel" %>
<% @main_title = "Extending the MicroKernel" %>
<%= render "/container/deflinks" %>

In this section we'll guide you through the possibilies offered
to augment the kernel functionality. By 'extending', we don't really
mean 'creating a subclass', although its possible, you don't really need
to do that for most of cases.

<h3>Facilities</h3>

<p>
Facilities are units of extension, usually for a family of components. 
They should extended the container by subscribing to MicroKernel events and
defining custom steps in the model construction and different activator
for complex components.
</p>

<h3>The ComponentModel</h3>

<p>
For each component added to the kernel, a few steps are performed.
One important step is the construction of the ComponentModel.
</p>

<p>
The ComponentModel holds all information the kernel needs about a component. These information
is collected by the ComponentModelBuilder implementation exposed by the MicroKernel. Well, in fact
the default ComponentModelBuilder implementation doesn't do much, it only allows 'contributors'
to be registered on it, and invoke them for each component registered. More about that later.
</p>

<p>
The rationale behind ComponentModel is to perform any heavy 
work during the container start up instead of
leaving the work to be performed on demand (and raising potential issues in multithreading environment). 
So information about lifecycle, lifestyle, available constructors
and properties that potentially refers to external dependencies, are kept in the
ComponentModel, but you can use the ComponentModel to hold more meta-information and use that later.
</p>

<p>
As we said, the ComponentModelBuilder has a collection of contributors. 
You can register your contributor to participate in this information collecting process 
so you can collect more information and even change the information collected by previous
contributors.
To do so, you must implement the interface 
<a href="http://svn.digitalcraftsmen.com.br/svn/castle/trunk/InversionOfControl/Castle.MicroKernel/ModelBuilder/IContributeComponentModelConstruction.cs">IContributeComponentModelConstruction</a>
 and add it to the <a href="http://svn.digitalcraftsmen.com.br/svn/castle/trunk/InversionOfControl/Castle.MicroKernel/ModelBuilder/DefaultComponentModelBuilder.cs">ComponentModelBuilder</a>
  exposed by the MicroKernel.
</p>

<p>
For example, follows the code that inspect if the component
implements lifecycle interfaces and add this information to be
used later:
</p>

<pre class="source">
using Castle.MicroKernel.LifecycleConcerns;

public class LifecycleModelInspector : 
  IContributeComponentModelConstruction
{
  public LifecycleModelInspector()
  {
  }

  public void ProcessModel(IKernel kernel, ComponentModel model)
  {
    if (typeof(IInitialize).IsAssignableFrom(model.Implementation))
    {
      model.LifecycleSteps.Add( LifecycleStepType.Commission, 
        InitializationConcern.Instance );
    }
    if (typeof(IDisposable).IsAssignableFrom(model.Implementation))
    {
      model.LifecycleSteps.Add( LifecycleStepType.Decommission, 
        DisposalConcern.Instance );
    }
  }
}
</pre>

<p>
More contributors used by the MicroKernel are <a href="http://svn.digitalcraftsmen.com.br/svn/castle/trunk/InversionOfControl/Castle.MicroKernel/ModelBuilder/Inspectors/ConfigurationModelInspector.cs">configuration</a>, 
<a href="http://svn.digitalcraftsmen.com.br/svn/castle/trunk/InversionOfControl/Castle.MicroKernel/ModelBuilder/Inspectors/ConstructorDependenciesModelInspector.cs">constructor dependencies</a>, 
<a href="http://svn.digitalcraftsmen.com.br/svn/castle/trunk/InversionOfControl/Castle.MicroKernel/ModelBuilder/Inspectors/ConstructorDependenciesModelInspector.cs">lifestyle</a> 
and <a href="http://svn.digitalcraftsmen.com.br/svn/castle/trunk/InversionOfControl/Castle.MicroKernel/ModelBuilder/Inspectors/PropertiesDependenciesModelInspector.cs">properties dependencies</a>.
</p>



<h3>Activators</h3>

<p>
The MicroKernel uses a implementation of <a href="http://svn.digitalcraftsmen.com.br/svn/castle/trunk/InversionOfControl/Castle.MicroKernel/ComponentActivator/IComponentActivator.cs">IComponentActivator</a>
 to create a set up a component instance. The default implementation
just select an appropriate constructor, instantiate the component, 
and sets properties it could resolve. 
However there are components that are not so easy to create.
Components that come from factories or builders, remote components and so on
 need a different approach.
In this case you can implement the IComponentActivator, or extend the
AbstractComponentActivator and specify your logic.
</p>


<h3>Events</h3>

<p>
The MicroKernel exposes the following events:
</p>

<ul>
<li>ComponentRegistered: fired when a new component is registered 
 on the kernel
</ul>

<ul>
<li>ComponentUnregistered: fired when a component is removed from the kernel.
</ul>

<ul>
<li>ComponentModelCreated: fired after the ComponentModel is created.
 Allows customizations that may affect the handler
</ul>

<ul>
<li>ComponentCreated: fired before the component is created.
</ul>

<ul>
<li>ComponentDestroyed: fired before the component is destroyed.
</ul>


<h3>Example: implementing the startable lifecycle</h3>

<p>
Suppose you'd like that every component that implements the IStartable marker interface
 added to the kernel 
be "started" as soon as possible.
</p>

<p>
Let's implement it by using a new facility:
</p>

<pre class="source">

public class StartableFacility : IFacility
{
  public void Init(IKernel kernel, IConfiguration config)
  {
    kernel.ComponentModelBuilder.AddContributor( 
      new StartableModelInspector() )
    
    kernel.ComponentRegistered += 
      new ComponentDataDelegate(OnComponentRegistered);
  }
  
  public void Terminate()
  {
  }
  
  private void OnComponentRegistered(String key, IHandler handler)
  {
    // The StartableModelInspector will add true to this key
    // see below
    if (model.ExtendedProperties["startable"] != null)
    {
      // If the minimal set of dependencies are satisfied
      if (handler.CurrentState == HandlerState.Valid)
      {
        // Instantiate
        handler.Resolve();
      }
    }
  }
}

public class StartableModelInspector : 
  IContributeComponentModelBuilder
{
  public void Process(IKernel kernel, ComponentModel model)
  {
    if (typeof(IStartable).IsAssignableFrom(model.Implementation))
    {
      model.ExtendedProperties.Add("startable", true);
    }
  }
}
</pre>

<h3>Conclusion</h3>

<p>
The MicroKernel was created to be extensible, so instead of
trying to foresee every single possibility and use case, we developed
just an small core that is prepared to have every piece of it 
augmented or replaced.
tool.
</p>


