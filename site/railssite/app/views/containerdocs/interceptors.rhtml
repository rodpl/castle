<% @page_title = "Documentation" %>
<% @main_title = "Interceptors" %>
<%= render "/containerdocs/deflinks" %>

Some containers usually always proxy every component. 
On other you have to proxy them to intercept something. 
Others leave to you the burden of constructing a chain of interceptors.
The MicroKernel exposes an interesting 
infrastructure to allow interceptors in a painless fashion.

<p>
Basically facilies can associate one or more interceptors with a component. 
When the component is activated the MicroKernel checks whether 
there's any interceptors associated with a component and if so, a proxy 
is created and a interceptor chain is associated with the proxy.
</p>

<pre class="source">
if (Something())
{
  model.Interceptors.Add( 
    new InteceptorReference( typeof(MyTransactionalInterceptor) ) );
}
</pre>

<p>
Usually the facility that associates components to 
interceptors is the same one that registered the interceptor. However,
if this is not your case, it would be nice to explicit say so to the kernel:
</p>

<pre class="source">
if (Something())
{
  model.Interceptors.Add( 
    new InteceptorReference( typeof(MyTransactionalInterceptor) ) );
  model.Dependencies.Add( 
    new DependencyModel( DependencyType.Service, "", typeof(MyTransactionalInterceptor), false ) );
}
</pre>

<p>
The last code snippet says to the kernel "hey, this component 
requires the existance of another component implementing the 
service 'MyTransactionalInterceptor' and this component will not be
available until this dependency is satisfied. 
</p>


<h3>The rationale behind this design</h3>

<p>
The whole principle behind Castle Project is orthogonality, so
by choosing this design, more than one facility could register 
their inteceptors to handle different concerns on the same component. 
Something that have been implemented, for example, is the
NHibernate facility that register an AutomaticSessionInterceptor,
and the Automatic Transaction Management facility that register an 
TransactionInterceptor to carry on with the Begins/Committs/Rollbacks.
</p>

<h3>What's an interceptor exactly?</h3>
 
<p>
An interceptor is a component registered like any other
component. The only requirement is that the inteceptor 
implements (correctly) the interface IMethodInterceptor.
</p>

<p>
As an example, we present you with the 
transactional interceptor code:
</p>

<pre class="source">
public class TransactionInterceptor : IMethodInterceptor
{
	private ITransactionManager _manager;

	public TransactionInterceptor(ITransactionManager manager)
	{
		_manager = manager;
	}

	public object Intercept(IMethodInvocation invocation, params object[] args)
	{
		if (!invocation.Method.IsDefined( typeof(TransactionAttribute), true ))
		{
			return invocation.Proceed(args);
		}
		else
		{
			object[] attrs = invocation.Method.GetCustomAttributes( 
				typeof(TransactionAttribute), true );

			TransactionAttribute transactionAtt = 
				(TransactionAttribute) attrs[0];

			ITransaction transaction = 
				_manager.CreateTransaction( 
					transactionAtt.TransactionMode, 
					transactionAtt.IsolationMode );

			object value = null;

			transaction.Begin();

			try
			{
				value = invocation.Proceed(args);

				transaction.Commit();
			}
			catch(Exception ex)
			{
				transaction.Rollback();
				throw ex;
			}
			finally
			{
				_manager.Dispose(transaction); 
			}
			
			return value;
		}
	}
}
</pre>

<p>&nbsp;</p>
