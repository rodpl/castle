<% @page_title = "Documentation" %>
<% @main_title = "Interceptors" %>
<%= render "/containerdocs/deflinks" %>

In others container you usually have to proxy a component 
in order to implement a chain of interceptors. The MicroKernel 
exposes an interesting infrastructure to allow interceptor in a 
painless fashion.

<p>
Basically facilies can associate one or more interceptors with a component. 
When the component is activated the MicroKernel checks whether 
is there any interceptors associated with a component and if so, a proxy 
is created and a interceptor chain is associated with the proxy.
</p>

<pre class="source">

if (Something())
{
  model.Interceptors.Add( 
    new InteceptorReference( typeof(MyTransactionalInterceptor) ) );
}

</pre>

<h3>The rationale behind this design</h3>

<p>
The whole principle behind Castle project is orthogonality, so
by choosing this design, more than one facility could register 
their inteceptors to handle different concerns. 
Something that have been implemented, for example, is the
NHibernate facility that register an AutomaticSessionInterceptor,
and the Automatic Transaction Management facility that register an 
TransactionInterceptor to carry on with the Begins/Committs/Rollbacks.
</p>

<h3>What's an interceptor exactly?</h3>
 
<p>
An interceptor is a component registered like any other
component. The only requirement is that the inteceptor must
implement (correctly) the interface IMethodInterceptor.
</p>

<p>
The transactional interceptor code follows:
</p>

<pre class="source">
public class TransactionInterceptor : IMethodInterceptor
{
	private ITransactionManager _manager;

	public TransactionInterceptor(ITransactionManager manager)
	{
		_manager = manager;
	}

	public object Intercept(IMethodInvocation invocation, params object[] args)
	{
		if (!invocation.Method.IsDefined( typeof(TransactionAttribute), true ))
		{
			return invocation.Proceed(args);
		}
		else
		{
			object[] attrs = invocation.Method.GetCustomAttributes( 
				typeof(TransactionAttribute), true );

			TransactionAttribute transactionAtt = 
				(TransactionAttribute) attrs[0];

			ITransaction transaction = 
				_manager.CreateTransaction( 
					transactionAtt.TransactionMode, 
					transactionAtt.IsolationMode );

			object value = null;

			transaction.Begin();

			try
			{
				value = invocation.Proceed(args);

				transaction.Commit();
			}
			catch(Exception ex)
			{
				transaction.Rollback();
				throw ex;
			}
			finally
			{
				_manager.Dispose(transaction); 
			}
			
			return value;
		}
	}
}
</pre>

<p>&nbsp;</p>
