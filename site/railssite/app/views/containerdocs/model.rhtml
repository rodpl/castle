<% @page_title = "Documentation" %>
<% @main_title = "Castle.Model" %>
<%= render "/containerdocs/deflinks" %>

The Castle.Model assembly is an independent layer to hold all
information the kernel collects and will use during its lifetime.

<p>
The reason to create a separated assembly is that sometimes you
might want to create a few assemblies exposing related components, and
instead of associate these assemblies with the MicroKernel, 
it will be better to associate it with a minor assembly that is more 
unlike to change. 
</p>

<h3>Attributes</h3>

<p>You can use the following attributes to decorate 
your components and thus expose information the kernel will use
to handle your component:</p>

<ul>
  <li>SingletonAttribute, TransientAttribute, PerThreadAttribute, CustomLifestyleAttribute:
  to manage lifestyle.</li>
</ul>

<ul>
  <li>InterceptorAttribute: to associate one or more interceptors with 
  the component.</li>
</ul>

<h3>Interceptors</h3>

<p>
There is another section dedicated to explain interceptors, 
for now just remember that interceptors are components registered
in the kernel, and they must implement the interface IMethodInterceptor.
</p>

<h3>ComponentModel</h3>

<p>
The following information is collect and kept for 
each component registered in the kernel. You can always
register facilities in the kernel to change and collect more
information to fit your needs.
</p>

<ul>
  <li>Constructor candidates: All public constructors available</li>
</ul>
<ul>
  <li>Property sets: all writable properties exposed</li>
</ul>
<ul>
  <li>Parameters: external data that might be used to fill properties and/or 
  constructors arguments. Also used to override components services.</li>
</ul>
<ul>
  <li>Dependencies: Primitive properties or services dependencies
  registered exclusively by IContributeComponentModelConstruction, ie, 
  there is no relation to constructors or properties exposed by the component</li>
</ul>


<p>&nbsp;</p>
